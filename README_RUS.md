# Классические задачи биоинформатики 

Реализация проекта DNA Analyzer.


## Contents

1. [Chapter I](#chapter-i) \
    1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) \
    2.1. [Information](#information)
3. [Chapter III](#chapter-iii) \
    3.1. [Part 1](#part-1-реализация-проекта-exact-dna-search)  
	3.2. [Part 2](#part-2-реализация-проекта-nw-sequence-alignment)  
	3.3. [Part 3](#part-3-соответствие-регулярным-выражениям)  
	3.4. [Part 4](#part-4-k-подобные-строки)  
	3.5. [Part 5](#part-5-дополнительно-минимальная-оконная-подстрока)  


## Chapter I

В очередной раз Еву занесло на новый странный проект, как это часто бывает в ее компании. В отдел исследований прикладной биоинформатики требовался человек способный писать непростые алгоритмы. В рамках сотрудничества с партнерской компанией в Британии они занимались проектом, позволяющим более качественно назначать пациентам лекарственные препараты, а для этого необходимо было реализовать тонну алгоритмов. Так как большинство из них уже было формализовано и не требовали особого знания биологии или погружения в тематику проекта, то можно было взять в помощь человека извне. \
Все звезды сошлись именно на Еве. Пришелся кстати ее опыт в алгоритмике, а также опыт предыдущего взаимодействия с ребятами из Advanced Solutions Inc., теми самыми британскими партнерами, в рамках многострадальных задач по лабиринтам.

В отделе исследований прикладной биоинформатики, не смотря на ожидания Евы, не было людей в белых халатах или колбочек с опасными вирусами, которые способны закрыть население целой планеты по домам на несколько лет. Вместо этого здесь сидели те же самые программисты и что-то выискивали в длинных непонятных строчках на экранах своих компьютеров. Они даже находились всего на пару этажей выше Евы. Ей пришлось на время переехать сюда, чтобы ускорить процесс коммуникации. Ева не сильно расстраивалась по этому поводу, рассудительно решив, что может лишний раз подкачать свои навыки алгоритмики на этом проекте. Однако, она сильно сожалела, что так и не удалось забрать ее любимое кресло..

## Introduction

В данном проекте вам предстоит познакомиться с классическими задачами биоинформатики -- поиском подстроки и выравниванием последовательностей, а также прочими алгоритмами обработки строк.


## Chapter II

## Information

Важной частью современной биоинформатики является анализ молекулярных последовательностей. Последовательностями называют строки над произвольным фиксированным алфавитом, например над алфавитом `{ A, C, G, T}` (последовательности ДНК). Вот примеры последовательностей ДНК, являющиеся частями вируса ВИЧ:

```
GGTCTCTCTGGTTAGACCAGATCTGAGC
CTGAGCCTGGGAGCTCTCTGGCTAACTAGGGAACCCACTG
AAGCCTCAAT
```

### Поиск подстроки

В анализе молекулярных последовательностей постоянно необходимо так или иначе сравнивать последовательности друг с другом. Например, бывает необходимо определить _точное совпадение_ двух строк, т.е. посимвольное совпадение строк одинакового размера. Более сложным, но реалистичным случаем является задача поиска подстроки, то есть поиска всех вхождений короткой строки (_needle_, "иголка") длины `m` в большую строку (_haystack_, "сено") длины `n`, `m <= n`. Помимо биоинформатики, задача поиска подстроки в разных вариациях повсеместно встречается в различных задачах _полнотекстового поиска_.

>*Пример:* \
>В строку `А роза упала на лапу Азора` подстрока `ла` входит дважды, на позицииях 11 и 17.

>*Пример:* \
>Относительно короткая последовательность вируса ВИЧ, состоящая приблизительно из десяти тысяч нуклеотидов (полностью посмотреть ее можно [здесь](https://www.ncbi.nlm.nih.gov/nuccore/AF033819)), содержит два вхождения строки `AAGCCTCAAT`, состоящей из десяти нуклеотидов.

Наивные решения поиска подстроки эффективны, если строки достигают в размере тысяч символов; для строк размеров в миллионы и более символов, а также для массированного поиска большого количества запросов, brute-force алгоритмы могут быть слишком медленны. Эффективные алгоритмы поиска подстроки не вполне тривиальны; одним из простых, но относительно эффективных алгоритмов является алгоритм Рабина-Карпа. Этот алгоритм основан на идее  _хеширования_ подстрок длины `m`, то есть вычисления некоторой функции, которая каждой строке ставит в соответствие некоторое число (хеш). Совпадение хеша для подстроки из "сена" с хешом "иголки" потенциально указывает на вхождение подстроки. Алгоритм превосходит наивные решения для входных данных достаточного размера, если хеш некоторой подстроки можно подсчитать, зная хеш подстроки, идущей перед ней.

### Выравнивание последовательностей

Молекулярные последовательности эволюционируют и изменяются со временем. В результате мутаций и других эволюционных событий, последовательности близких организмов со временем эволюционно отдаляются друг от друга и становятся все менее схожи. Для сравнения неидеально совпадающих последовательностей, алгоритмов точного поиска недостаточно; чтобы сопоставлять такие последовательности, применяют _выравнивание_. Выравниванием двух последовательностей называют их запись одну под другой, при которой в обе последовательности внесены дополнительные "пробелы", или "гэпы". Эти гэпы расставлены таким образом, чтобы стоящие друг под другом буквы последовательностей совпадали. Например, выравнивание двух последовательностей `GGGCGACACTCCACCATAGA` и `GGCGACACCCACCATACAT` (небольшие кусочки из начала геномов двух версий вируса гепатита C), может выглядеть так:

```
GGGCGACACTCCACCATAGA-
|| |||||| |||||||| |
GG-CGACAC-CCACCATACAT
```

Заметьте, что двум последовательностям может соответствовать большое число разных выравниваний (с разным количество совпадающих позиций). С биологической точки зрения выравнивание помогает определить те позиции в последовательностях, которые наиболее вероятно являются гомологичными, то есть имеющими общее эволюционное происхождение. В учебных целях мы можем полагать, что целью выравнивания является максимизация количества совпадающих символов в выравнивании и минимизация несовпадающих. Классическим решением данной задачи является алгоритм Нидлмана-Вунша, предложенный в 1970 году и основанный на идее динамического программирования. Данный алгоритм полагается на функцию "похожести", которая оценивает "стоимость" ("скор" от англ. "score") совпадения или несовпадения символов, записанных друг под другом, и максимизирует общую "похожесть" выравнивания.

>*Пример:* \
>Стоимость совпадения 1, стоимость несовпадения -1, стоимость гэпа -2. Тогда выравнивание из предыдущего примера достигает общей стоимости 10: 17 совпадающий символов, 1 несовпадающий, 3 гэпа.


Продвинутые версии этого алгоритма используют матрицы похожести, где стоимость совпадений и несовпадений может различаться для разных пар символов. 


## Chapter III

**Общие** указания для выполнения всех частей:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- При написании кода необходимо придерживаться Google Style
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Предусмотреть Makefile для сборки библиотеки и тестов (с целями all, clean, tests, app)
- Должно быть обеспечено полное покрытие unit-тестами всех функций/методов, используемых при реализации каждого задания
- У программы должен быть предусмотрен консольный интерфейс

## Part 1. Реализация проекта Exact DNA search

Разработать программу для полнотекстового поиска при помощи **алгоритма Рабина-Карпа**. \
Программа принимает на вход *два* файла. Они содержат последовательности `a` и `b` длины `n <= 10000` и `m <= 100` соответственно, `m <= n`. Выходом программы является список позиций строки `a`, на которых `b` входит в `a`.

Пример входа: \
Файл `datasets/HIV-1_AF033819.3.txt` и файл со следующим содержимым:
```
AAGCCTCAATAAAGCTT
```

Пример выхода:
```
65 9150 9182
```

#### Проверка времени выполнения и потребления памяти

На Unix-like операционных системах есть утилита `/usr/bin/time` (не путать с командой `time` в `bash`). Проверить время работы и потребление программы можно при помощи следующей команды:
```
/usr/bin/time -v PROGRAM
```
где `PROGRAM` соответствует названию исполняемого файла. Вывод `/usr/bin/time` может выглядеть приблизительно так:
```
	Command being timed: "./nw"
	User time (seconds): 0.00
	System time (seconds): 0.00
	Percent of CPU this job got: 75%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.00
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 3284
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 137
	Voluntary context switches: 1
	Involuntary context switches: 0
	Swaps: 0
	File system inputs: 0
	File system outputs: 0
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 0
```
Вас интересует время (`Elapsed (wall clock) time`) и память (`Maximum resident set size (kbytes)`).

Максимальное время работы: 1 сек \
Максимальное потребление памяти: 128 Мб

## Part 2. Реализация проекта NW sequence alignment

### Part 2.1 Вычисление оптимального скора

Разработать программу для выравнивания двух последовательностей над алфавитом `{A, C, G, T}`. \
Входом программы является файл с *тремя* строчками. Первая строка содержит три числа - стоимость совпадения, несовпадения и гэпа. Две следующие строки -- последовательности для выравнивания. Выходом программы является *одно* число -- значение скора для наиболее оптимального выравнивания. 

Пример ввода:
```
1 -1 -2
GGGCGACACTCCACCATAGA
GGCGACACCCACCATACAT
```

Пример вывода:
```
10
```

### Part 2.2 Восстановление оптимального выравнивания

Добавить в программу восстановление оптимального выравнивания, для которого достигается максимальный скор. Выходом программы является значение максимального скора, а под ним -- запись двух строк одна под другой с внесенными в строки гэпами. Совпадающие символы на одинаковых позициях отмечаются вертикальной чертой.

Пример вывода:
```
10
GGGCGACACTCCACCATAGA-
|| |||||| |||||||| |
GG-CGACAC-CCACCATACAT
```

#### Проверка времени выполнения и потребления памяти

См. инструкции к [первой задаче](#part-1-реализация-проекта-exact-dna-search).

Максимальное время работы: 1 сек \
Максимальное потребление памяти: 128 Мб

## Part 3. Соответствие регулярным выражениям

Разработать программу для проверки соответствия последовательности над алфавитом `{A, C, G, T}` регулярному выражению. \
Входом программы является файл с *двумя* строчками. Первая строка содержит последовательность, для которой будет проверяться соответствие. Вторая строка содержит паттерн, содержащий символы из алфавита и следующие символы:
- `.` -- соответствует любому отдельному символу из алфавита;
- `?` -- соответствует любому отдельному символу из алфавита или отсутствию символа;
- `+` -- соответствует нулю или более повторений предыдущего элемента;
- `*` -- соответствует любой последовательности символов из алфавита или отсутствию символов.

Выходом программы является *Истина*/*Ложь* - соответствует ли заданная последовательность паттерну.

Пример ввода:
```
GGCGACACCCACCATACAT
G?G*AC+A*A.
```

Пример вывода:
```
True
```

**Внимание: При выполнении этой части запрещено использовать готовые библиотеки для работы с регулярными выражениями, такие как _regex_ или _PCRE_**

## Part 4. K-подобные строки

Строки s1 и s2 k-подобны (для некоторого неотрицательного целого числа *k*), если возможно поменять местами две буквы в s1 ровно *k* раз так, чтобы результирующая строка была равна s2.

Разработать программу для проверки k-подобия двух последовательностей над алфавитом `{A, C, G, T}`. \
Входом программы является файл с *двумя* строчками. Выходом программы является наименьшее *k*, для которого s1 и s2 k-подобны. Если строки не являются анаграммами, вывести сообщение об ошибке.

Пример ввода:
```
GGCGACACC
AGCCGCGAC
```

Пример вывода:
```
3
```


## Part 5. Дополнительно. Минимальная оконная подстрока

Подстрока - это непрерывная последовательность символов внутри строки.

Разработать программу для минимальной оконной подстроки для последовательности над алфавитом `{A, C, G, T}`. \
Входом программы является файл с *двумя* строчками s и t. Оконной подстрокой строки s называется подстрока, содержащая все символы, входящие в строку t (включая дубликаты).
Выходом программы является оконная подстрока минимальной длины. Если оконной подстроки нет, вернуть пустую строку.

Пример ввода:
```
GGCGACACCCACCATACAT
TGT
```

Пример вывода:
```
GACACCCACCATACAT
```

*Пояснение:*

Подстрока, являющаяся результатом, должна содержать символы `T`, `G`, `T`. Подходящими подстроками являются следующие:
```
GACACCCACCATACAT
CGACACCCACCATACAT
GCGACACCCACCATACAT
GGCGACACCCACCATACAT
```

При этом результатом является подстрока _минимальной_ длины, поэтому выбираем первый вариант.
